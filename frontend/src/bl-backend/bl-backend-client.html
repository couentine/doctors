<!-- #=== POLYMER & SHIMS ===# -->
<link rel="import" href="../../bower_components/polymer/polymer.html">

<!-- #=== SWAGGER JS CLIENT ===# -->
<script src="swagger-client.min.js" type="text/javascript"></script>

<!-- #=== BADGE LIST COMPONENTS ===# -->
<link rel="import" href="../bl-app/bl-app-component-mixin.html">

<!--
# Badge List Backend Client #

This is a wrapper around the 2.x version of the [Swagger JS Client](https://github.com/swagger-api/swagger-js/tree/2.x).
(The 3.0 version of the swagger js library requires a more complex build process so for now we're using the 2.x branch.)
There is only one backend client for the whole app, stored in the `<bl-app>` component with id `backend`. You can access the client
from any component using the component mixin with `this.app.$.backend`.

You shouldn't need to reference this directly from a component, though. It is designed to be used via on of the model binding elements
contained in the `bl-backend` folder.

The client uses the `swagger.json` file located in the component folder.
-->
<dom-module id="bl-backend-client">
  <template>
  </template>

  <script>
    class BlBackendClient extends BlAppComponentMixin(Polymer.Element) {
      
      static get is() { return 'bl-backend-client'; }

      static get properties() {
        return {
          
          client: Object,

          initialized: {
            type: Boolean,
            value: false,
            notify: true
          }

        };
      }

      // #=== PUBLIC ACTION METHODS ===#

      /** 
       * Fires the specified operation and returns a promise with either the response object OR an error. Parameters is optional.
       * Example usage: `doAction('myBadges', 'getMyBadges', { page: 2 }).then(function(response) { console.log(response) })`
       */
      doAction(tag, operationId, parameters) {
        return new Promise(function(resolve, reject) {
          this.client[tag][operationId](parameters).then(function(responseDetails) {
            resolve(responseDetails.obj);
          }).catch(function(error) {
            reject(error);
          });
        }.bind(this));
      }

      /**
       * Returns an object full of callbacks to the `doAction` method for each available action on the specified tag.
       * The object is organized by tag such that there will be one key for each additional tag present in the actions.
       * Each key then contains an object with subkeys for the stripped down action names (ex: `get`, `delete`).
       * Each subkey's value is a callback accpeting a single parameters argument and returning a promise generated by `doAction`.
       */ 
      buildActionCallbacks(tag) {
        var returnObject = {};
        var operationTags; var operationIds; var operationId;
        var callbackFunction; var actionName;

        operationIds = Object.getOwnPropertyNames(this.client[tag].operations);
        for (var i = 0; i < operationIds.length; i++) {
          // Build the callback for this operation, which should accept a parameters argument from the consumertext itself)
          operationId = operationIds[i]; // need to flatten in order to get closure to work
          callbackFunction = (parameters) => this.doAction(tag, operationId, parameters);

          // The action name is the same as the operationId w/o the tag text (ex: `getMyBadges` => `get')
          actionName = operationId.replace(new RegExp(tag, 'i'), '');

          // Loop through operation tags and add a copy of this action for each tag we find that isn't the original tag
          operationTags = this.client[tag].operations[operationIds[i]].operation.tags;
          for (var j = 0; j < operationTags.length; j++)
            if (operationTags[j] != tag) {
              if (!returnObject[operationTags[j]]) returnObject[operationTags[j]] = {};
              returnObject[operationTags[j]][actionName] = callbackFunction;
            }
        }

        return returnObject;
      }

      // #=== LIFECYCLE EVENTS ===#

      connectedCallback() {
        if (super.connectedCallback) super.connectedCallback();

        var self = this;
        var apiHost = this.app.manifest.app_root_url.replace(/https?:\/\//i, '');

        // Initialize the swagger client
        this.client = new SwaggerClient({
          url: Polymer.rootPath + "/src/bl-backend/swagger.json",
          usePromise: true
        }).then(function(client) {
            // We need to override the host if we are in a non-production environment
            if (client.host != apiHost)
              client.setHost(apiHost);
            
            self.client = client;
            self.initialized = true;
        }).catch(function(errorMessage) {
            self.openAlertDialog({
              color: 'orange', 
              title: 'Connection problem',
              body: 'There was a problem connecting with the Badge List server. Please review the error message below '
                + 'and try reloading the page.<br><br><strong>Error Message:</strong> ' + errorMessage,
              dismiss: { text: 'Close', action: function(){} }
            });
        });
      }

    }

    window.customElements.define(BlBackendClient.is, BlBackendClient);
  </script>
</dom-module>
