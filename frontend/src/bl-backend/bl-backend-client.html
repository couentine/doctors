<!-- #=== POLYMER & SHIMS ===# -->
<link rel="import" href="../../bower_components/polymer/polymer.html">

<!-- #=== SWAGGER JS CLIENT ===# -->
<!-- NOTE: This is now imported in the rails polymer.html.erb layout. -->
<!-- <script src="swagger-client.min.js" type="text/javascript"></script> -->

<!-- #=== BADGE LIST COMPONENTS ===# -->
<link rel="import" href="../bl-app/bl-app-component-mixin.html">

<!--
# Badge List Backend Client #

This is a wrapper around the 2.x version of the [Swagger JS Client](https://github.com/swagger-api/swagger-js/tree/2.x).
(The 3.0 version of the swagger js library requires a more complex build process so for now we're using the 2.x branch.)
There is only one backend client for the whole app, stored in the `<bl-app>` component with id `backend`. You can access the client
from any component using the component mixin with `this.app.$.backend`.

You shouldn't need to reference this directly from a component, though. It is designed to be used via on of the model binding elements
contained in the `bl-backend` folder.

The client uses the `swagger.json` file located in the component folder.
-->
<dom-module id="bl-backend-client">
  <template>

    <style include="bl-style-classes"></style>

    <!-- #=== API ERROR DIALOG ===# -->
    <paper-dialog id="connectionErrorDialog" class="red" modal dynamic-align>
      <h2>Connection Problem</h2>

      <div class="formIcon">
        <i class="icon-connection-warning"></i>
      </div>
            
      <div class="dialogContent">
        <p>
          There was a problem connecting with the Badge List server. Please review the error message below and try reloading the page.
        </p>
        <p>
          <strong>Error Message:</strong> [[connectionErrorMessage]]
        </p>
      </div>

      <div class="buttons">
        <paper-button class="red primary" on-tap="saveItem" dialog-dismiss>
          Close
        </paper-button>
      </div>
    </paper-dialog>
  </template>

  <script>
    class BlBackendClient extends BlAppComponentMixin(Polymer.Element) {
      
      static get is() { return 'bl-backend-client'; }

      static get properties() {
        return {
          
          client: Object,

          initialized: {
            type: Boolean,
            value: false,
            notify: true
          },

          connectionErrorMessage: String

        };
      }

      // #=== PUBLIC ACTION METHODS ===#

      /** 
       * Fires the specified operation and returns a promise with either the response object OR an error. Parameters is optional.
       * Example usage: `doOperation('myBadges', 'getMyBadges', { page: 2 }).then(function(response) { console.log(response) })`
       */
      doOperation(tag, operationId, parameters) {
        // Add the CSRF token if needed
        var operationPropertyNames = this.client[tag].operations[operationId].parameters.map(function(property) {
          return property.name;
        });
        if (operationPropertyNames.includes('X-CSRF-Token'))
          parameters['X-CSRF-Token'] = this.app.manifest.csrf_token;

        return new Promise(function(resolve, reject) {
          this.client[tag][operationId](parameters).then(function(responseDetails) {
            resolve(responseDetails.obj);
          }).catch(function(error) {
            reject(error);
          });
        }.bind(this));
      }

      /**
       * Returns an object organized with a key for each tag and subkey for each operation. Each operation key has a `do` function and 
       * a `parameters` object which stores details of the parameters and their schemas.
       * The root object keys are organized by tag such that there will be one key for each additional tag present in the operations.
       * Each key then contains an object with subkeys for the stripped down action names (ex: `get`, `delete`).
       * Each subkey's `do` function is a callback accepting a single `parameters` argument, returning a promise generated by `doOperation`.
       * Each subkey's `parameters` object is a copy of the swagger `parameters` array mapped by parameter name.
       */ 
      operationsByTag(tag) {
        var returnObject = {};
        var operationTags; var operationIds; var operationId;
        var callbackFunction; var actionName;

        operationIds = Object.getOwnPropertyNames(this.client[tag].operations);
        for (var i = 0; i < operationIds.length; i++) {
          // Build the callback for this operation, which should accept a parameters argument from the consumertext itself)
          operationId = operationIds[i]; // need to flatten in order to get closure to work
          callbackFunction = (parameters) => this.doOperation(tag, operationId, parameters);

          // The action name is the same as the operationId w/o the tag text (ex: `getMyBadges` => `get')
          actionName = operationId.replace(new RegExp(tag, 'i'), '');

          // Loop through operation tags and add a copy of this action for each tag we find that isn't the original tag
          operationTags = this.client[tag].operations[operationIds[i]].operation.tags;
          for (var j = 0; j < operationTags.length; j++)
            if (operationTags[j] != tag) {
              if (!returnObject[operationTags[j]]) returnObject[operationTags[j]] = {};
              returnObject[operationTags[j]][actionName] = {
                do: callbackFunction,
                parameters: this.client[tag].operations[operationId].parameters.reduce(
                  function(parametersObject, parametersItem) {
                    parametersObject[parametersItem.name] = parametersItem;
                    return parametersObject; 
                  }, {})
              };
            }
        }

        return returnObject;
      }

      /**
       * Returns the `properties` object from the model definition. There is one key for each field.
       * `modelReferenceString` can be either a model name (ex: `BadgeEndorsement`) 
       * or a model reference string (ex: `#/definitions/BadgeEndorsement`).
       */
      modelProperties(modelReferenceString) {
        var modelName;
        
        if (modelReferenceString.includes('/'))
          modelName = modelReferenceString.split('/')[2];
        else
          modelName = modelReferenceString;

        return this.client.models[modelName].definition.properties;
      }

      // #=== LIFECYCLE EVENTS ===#

      connectedCallback() {
        if (super.connectedCallback) super.connectedCallback();

        var self = this;
        var apiHost = this.app.manifest.app_root_url.replace(/https?:\/\//i, '');

        // Initialize the swagger client
        this.client = new SwaggerClient({
          url: Polymer.rootPath + "/src/bl-backend/swagger.json",
          usePromise: true
        }).then(function(client) {
            // We need to override the host if we are in a non-production environment
            if (client.host != apiHost)
              client.setHost(apiHost);
            
            self.client = client;
            self.initialized = true;
        }).catch(function(errorMessage) {
            self.connectionErrorMessage = errorMessage;
            self.$.connectionErrorDialog.open();
        });
      }

    }

    window.customElements.define(BlBackendClient.is, BlBackendClient);
  </script>
</dom-module>
