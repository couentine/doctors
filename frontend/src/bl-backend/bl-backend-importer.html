<!-- #=== POLYMER & SHIMS ===# -->
<link rel="import" href="../../bower_components/polymer/polymer.html">

<!-- #=== BADGE LIST COMPONENTS ===# -->
<link rel="import" href="../bl-app/bl-app-component-mixin.html">

<!-- #=== BADGE LIST COMPONENTS ===# -->
<script type="text/javascript" src="../../lib/PapaParse-4.3.2/papaparse.min.js"></script>

<!--
# Badge List Backend List Importer #

Use this component to bind a local component property with an import list endpoint in the Badge List backend.
The target object provides methods for building a list of items to import either manually or by importing from a local CSV file.
-->
<dom-module id="bl-backend-importer">
  <template>
  </template>

  <script>
    class BlBackendImporter extends BlAppComponentMixin(Polymer.Element) {
      
      static get is() { return 'bl-backend-importer'; }

      static get properties() {
        return {
          
          /** 
           * Required. The list type corresponds to a tag in swagger and determines the item properties.
           */
          type: String,

          /** 
           * This controls the number of items included in each import batch. It is set automatically to the `maxItems` value from the
           * swagger spec, but it can be specified manually instead. If the manually specified value is higher than the `maxItems` value
           * then it will be ignored.
           */
          importBatchSize: Number,

          /** Optional. Additional parameters to pass to the import action. */
          parameters: {
            type: Object,
            notify: true,
            value: function() { return {} }
          },

          /**
           * Required. The target object receiving the binding. The following properties and methods are added on connection.
           * @property {object[]} itemsToImport - The items passed in the body of the import action.
           *   You can add new items by using the `addItem` or `addItemsFromCSV` methods, but shouldn't modify the list directly.
           *   Each item has a `backend` object added to it which will contain: a `status` object, 
           *   the `result` object returned from the server, a `remove()` function which will remove the specified item from the list.
           *   `status.code` will equal `ready`, `importing` or `failed`
           *   You can also use `status.isReady`, `status.isImporting` and `status.isFailed` to check the status.
           * @property {object[]} importedItems - After items are successfully imported they are removed from `itemsToImport` and added to
           *   this list. The items in this list have all of the same properties except there is no `remove()` method.
           * @property {object} status - Stores the current state of the import process.
           * @property {string} status.code - Equal to `uninitialized`, `ready`, `parsing`, `mapping`, `importing` or `error`.
           * @property {boolean} status.isReady - No network action is pending. True whenever the status is 'ready'.
           * @property {boolean} status.isParsing - An import is in progress. True whenever the status is 'parsing'.
           * @property {boolean} status.isMapping - An import is in progress. True whenever the status is 'mapping'.
           * @property {boolean} status.isImporting - An import is in progress. True whenever the status is 'importing'.
           * @property {boolean} status.isError - True if the status is 'error'.
           * @property {string} status.errorMessage - Error message from backend. Null unless `isError` is `true`.
           * @property {number} status.currentBatch - The number of the current import batch. From 1 to `batchCount`.
           * @property {number} status.batchCount - The total number of batches in the current import process.
           * @property {object} status.poller - Stores the poller object for the current import batch. Updated in real time.
           * @property {function} addItem() - Shortcut to access the component method. Refer to method comments for docs.
           * @property {function} addItemsFromCSV(filePath) - Shortcut to access the component method. Refer to method comments for docs.
           * @property {function} finishMapping() - Shortcut to access the component method. Refer to method comments for docs.
           * @property {function} cancelParsing() - Shortcut to access the component method. Refer to method comments for docs.
           * @property {function} clearItems() - Shortcut to access the component method. Refer to method comments for docs.
           * @property {object[]} itemProperties - Stores a copy of the properties object of the swagger schema used for the imported items 
           *   array. Object property names are the item keys, values are objects with properties for `type`, `description` 
           *   and potentially `format`.
           * @property {string[]} csvColumns - Ordered list of column headers from the CSV file. Set whenever `addItemsFromCSV` is called.
           * @property {object} csvColumnMap - Key-value store used to match CSV column headers with item property names. 
           *   `csvColumnMap` is automatically updated whenever `addItemsFromCSV` is called. Keys are the names of all the `itemProperties`,
           *    values are strings corresponding to values from `csvColumns`.
           * @property {function} import() - Initiates the import process. If `itemsToImport` has more than `importBatchSize` items then 
           *   the process will be broken up into multiple batches.
           */
          target: {
            type: Object,
            notify: true,
            value: function() { return {} }
          },

          /** Caches the most recently return results from Papa Parse. */
          _lastParseResults: {
            type: Object,
            readOnly: true
          },

          /** 
           * Set using the `operationsByTag` method in `<bl-backend-client>`. Used to power public action methods.
           * Consuming components should not reference this object directly as it may change with future implementations.
           */
          _backendOperations: {
            type: Object,
            readOnly: true
          }

        }
      }

      // #=== PUBLIC ACTION METHODS ===#

      /** Adds a new blank item to the end of `target.itemsToImport` array. Returns the new item. */
      addItem() {
        var item = this._buildItem();

        this.push('target.itemsToImport', item);

        return item;
      }

      /** 
       * Adds items from a local CSV file to the `itemsToImport` array.
       * The CSV column headers are automatically matched with the itemProperties if possible. CSV parsing happens asynchronously.
       * status will go to `parsing` while the parse process is running. 
       *
       * If CSV column headers are automatically matched or if all of the itemProperties are matched then the parsing process will complete
       * and the status will return to `ready`. 
       *
       * If the automatic column matching failed to match everything then status will go to `mapping`.
       * You can then optionally use the `csvColumnMap` property to fill in the remaining mappings, then call `finishMapping`.
       *
       * If an error occurs during the parsing process it will be indicated in `target.status.code` and `target.status.errorMessage`.
       */
      addItemsFromCSV(file) {
        if (this.target.status.code == 'ready') {
          this._updateStatus('parsing');
          
          Papa.parse(file, {
            header: true,
            dynamicTyping: true,
            skipEmptyLines: true,
            complete: (parseResults) => this._processParseResults(parseResults),
            error: (error) => this._updateStatus('error', error)
          });
        }
      }

      /**
       * Finishes adding items from a CSV file when the initial call to `addItemsFromCSV` resulted in going to status `mapping`.
       * `finishMapping` will always result in going to status `ready` unless there is an error.
       */
      finishMapping() {
        if (this.target.status.code == 'mapping')
          this._processParseResults(); // uses previously cached results
      }

      /** Aborts a pending CSV import and returns the status to `ready`. */
      cancelParsing() {
        if ((this.target.status.code == 'parsing') || (this.target.status.code == 'mapping'))
          this._updateStatus('ready');
      }

      /** Removes all items from `target.itemsToImport` array. Returns the removed items. */
      clearItems() {
        return this.splice('target.itemsToImport', 0, this.target.itemsToImport.length);
      }

      /** xxxxxxx */
      import() {
        // ...
      }

      /** Removes the matching item from `target.itemsToImport` array and returns the removed item (or null if no match is found). */
      removeItem(uniqueId) {
        var itemIndex = null;

        for (var i = 0; i < this.target.itemsToImport.length; i++)
          if (this.target.itemsToImport[i].uniqueId == uniqueId) {
            itemIndex = i;
            break;
          }

        if (itemIndex != null)
          return this.splice('target.itemsToImport', itemIndex, 1)[0];
        else
          return null;
      }
      
      // #=== PRIVATE ACTION METHODS ===#

      /** 
       * Sets and notifies all of the target properties related to status. Only include error if statusCode is 'error'. 
       * 'error' can be an error object or a string.
       */
      _updateStatus(statusCode, error) {
        var isReady = (statusCode == 'ready');
        var isParsing = (statusCode == 'parsing');
        var isMapping = (statusCode == 'mapping');
        var isImporting = (statusCode == 'importing');
        var isError = (statusCode == 'error');

        this.set('target.status.code', statusCode);

        // Only trigger a notification for the booleans if they are changing
        if (this.target.status.isReady != isReady) this.set('target.status.isReady', isReady);
        if (this.target.status.isParsing != isParsing) this.set('target.status.isParsing', isParsing);
        if (this.target.status.isMapping != isMapping) this.set('target.status.isMapping', isMapping);
        if (this.target.status.isImporting != isImporting) this.set('target.status.isImporting', isImporting);
        if (this.target.status.isError != isError) this.set('target.status.isError', isError);

        // Always trigger a notification for the error message, but ensure that it's always null if there's no error
        if (isError) this.set('target.status.errorMessage', ((error && error.message) ? error.message : error));
        else this.set('target.status.errorMessage', null);
      }

      /** Initializes the object bound to the target property. Adds callbacks and sets initial property values. */
      _setupTargetObject() {
        // Add to the existing target object instead of overwriting it, in case the parent element has given it extra properties
        this.set('target.itemsToImport', []);
        this.set('target.importedItems', []);
        this.set('target.status', {});
        this.set('target.status.code', 'uninitialized');
        this.set('target.status.isReady', false);
        this.set('target.status.isParsing', false);
        this.set('target.status.isMapping', false);
        this.set('target.status.isImporting', false);
        this.set('target.status.isError', false);
        this.set('target.status.errorMessage', null);
        this.set('target.status.currentBatch', null);
        this.set('target.status.batchCount', null);
        this.set('target.status.poller', {});
        this.set('target.itemProperties', {});
        this.set('target.csvColumns', []);
        this.set('target.csvColumnMap', {});

        // No need to notify for these ones
        this.target.addItem = () => this.addItem();
        this.target.addItemsFromCSV = (filePath) => this.addItemsFromCSV(filePath);
        this.target.finishMapping = () => this.finishMapping();
        this.target.cancelParsing = () => this.cancelParsing();
        this.target.clearItems = () => this.clearItems();
        this.target.import = () => this.import();
      }

      /** 
       * Processes the results of Papa Parse and moves to next status (status means `target.status.code`). 
       * If status is `parsing` and there are unmatched fields then we move to status `mapping` to provide a chance to map more fields.
       * If all possible fields are matched (or if we're already at status `mapping`) then we will go to status `ready` unless
       * there is an error. (Errors always result in going to status `error`.)
       *
       * @param {object} parseResults - The results of `Papa.parse`. If ommitted, `this._lastParseResults` is used instead.
       */
      _processParseResults(parseResults) {
        try {
          var itemPropertyList = Object.getOwnPropertyNames(this.target.itemProperties);
          var matchingColumnName;
          var allMatchedColumnNames = [];
          var unmatchedPropertyCount = 0;
          var unmatchedColumnCount = 0;

          if (parseResults)
            this._set_lastParseResults(parseResults);
          else
            parseResults = this._lastParseResults;

          // Update the CSV column names, filtering out blank columns
          this.set('target.csvColumns', parseResults.meta.fields.filter(function(columnName) {
            return columnName && columnName.length && columnName.trim().length; 
          }));

          // Update the csvColumnMap, keeping previous matches unless they point to a column that no longer exists
          for (var i = 0; i < itemPropertyList.length; i++) {
            matchingColumnName = this.target.csvColumnMap[itemPropertyList[i]];

            if (!matchingColumnName || !this.target.csvColumns.includes(matchingColumnName)) {
              matchingColumnName = this._findMatchingCSVColumn(itemPropertyList[i]);
              this.target.csvColumnMap[itemPropertyList[i]] = matchingColumnName;
            }
            
            if (matchingColumnName)
              allMatchedColumnNames.push(matchingColumnName);
            else
              unmatchedPropertyCount++;
          }
          unmatchedColumnCount = this.target.csvColumns.reduce(function(unmatchedCount, columnName) {
            return unmatchedCount + (allMatchedColumnNames.includes(columnName) ? 0 : 1);
          }, 0);


          if ((this.target.status.code == 'parsing') && unmatchedPropertyCount && unmatchedColumnCount) {
            // We only go to the mapping status if there are unmatched properties AND potential columns to match, otherwise just go ahead
            this._updateStatus('mapping');
          } else {
            // Translate the parse data items into import items and add them to `target.itemsToImport`
            for (var i = 0; i < parseResults.data.length; i++)
              this.push('target.itemsToImport', this._buildItem(parseResults.data[i]));
            
            this._updateStatus('ready');
          }
        } catch(e) {
          throw e;
          this._updateStatus('error', e);
        }
      }

      // #=== LIFECYCLE EVENTS ===#

      connectedCallback() {
        if (super.connectedCallback) super.connectedCallback();

        // Add a listener for the backend client status
        this.app.$.backend.addEventListener('initialized-changed', e => this._appBackendInitializedChanged(e));
        
        // Setup the target object
        this._setupTargetObject();
      }

      // #=== LISTENER & OBSERVER METHODS ===#

      /** This method initializes the backend related properties of the component after the backend client is initialized. */
      _appBackendInitializedChanged(e) {
        if (e.detail.value) {
          this._set_backendOperations(this.app.$.backend.operationsByTag(this.type));
          
          var schemaMaxItems = this._backendOperations.importList.import.parameters.items.schema.maxItems;
          if (!this.importBatchSize || (this.importBatchSize > schemaMaxItems))
            this.importBatchSize = schemaMaxItems;

          var itemModelReferenceString = this._backendOperations.importList.import.parameters.items.schema.items.$ref;
          this.set('target.itemProperties', this.app.$.backend.modelProperties(itemModelReferenceString));

          this._updateStatus('ready');
        }
      }

      // #=== PRIVATE HELPER & UTILITY METHODS ===#

      /** 
       * Returns a new item ready to add to `itemsToImport` with all properties specified in `target.itemProperties`.
       * @param {object} csvItem - Optional. A data item parsed from a csv file. If included this will be used to populate the item's
       *   properties. The items keys will be translated using `target.csvColumnMap`.
       */
      _buildItem(csvItem) {
        var item = Object.getOwnPropertyNames(this.target.itemProperties).reduce(
          function(itemObject, propertyName) {
            if (csvItem)
              itemObject[propertyName] = csvItem[this.target.csvColumnMap[propertyName]];
            else
              itemObject[propertyName] = null;
            
            return itemObject;
          }.bind(this), {}
        );

        item.uniqueId = Math.random().toString(36).slice(2); // used to identify this item later
        item.status = {
          code: 'ready',
          isReady: true,
          isImporting: false,
          isFailed: false
        };
        item.result = null;
        item.remove = () => this.removeItem(item.uniqueId);

        return item;
      }

      /** Returns matching entry from `csvColumns` if found, otherwise returns null. */
      _findMatchingCSVColumn(itemPropertyName) {
        var matchingColumnName;
        var simplifiedPropertyName;
        var simplifiedColumnName;

        // First build the simplified names and look for perfect matches
        simplifiedPropertyName = itemPropertyName.toLowerCase().replace(/[^a-z]/g, '');
        for (var i = 0; !matchingColumnName && (i < this.target.csvColumns.length); i++) {
          simplifiedColumnName = this.target.csvColumns[i].toLowerCase().replace(/[^a-z]/g, '');

          if (simplifiedColumnName == simplifiedPropertyName)
            matchingColumnName = this.target.csvColumns[i];
        }

        // Now look for partial matches if needed
        if (!matchingColumnName)
          for (var i = 0; !matchingColumnName && (i < this.target.csvColumns.length); i++)
            if (this.target.csvColumns[i].toLowerCase().includes(simplifiedPropertyName))
              matchingColumnName = this.target.csvColumns[i];

        return matchingColumnName;
      }

    }

    window.customElements.define(BlBackendImporter.is, BlBackendImporter);
  </script>
</dom-module>
