<!-- #=== POLYMER & SHIMS ===# -->
<link rel="import" href="../../bower_components/polymer/polymer.html">

<!-- #=== BADGE LIST COMPONENTS ===# -->
<link rel="import" href="../bl-app/bl-app-component-mixin.html">

<!--
# Badge List Backend Record Item #

Use this component to bind a local component property with a record item in the Badge List backend.
This is a reusable way to interact with any endpoints marked with the `recordItemFormat` tag.
-->
<dom-module id="bl-backend-item">
  <template>
  </template>

  <script>
    class BlBackendItem extends BlAppComponentMixin(Polymer.Element) {
      
      static get is() { return 'bl-backend-item'; }

      static get properties() {
        return {

          /** 
           * Required. The swagger model name.
           */
          model: String,

          /** 
           * Optional. The model name of the parent model. This will change the way that the querying process works. If parentModel is 
           * blank then this component will query as soon as `key` is set, otherwise it will wait until both `key` and `parentKey` are set.
           */
          parentModel: String,
          
          /** 
           * You must use a key which is acceptible by the API. If there is no parent model that means you can only use the record id
           * or (for root level objects like group and user), the slug. The there *is* a parent model then you should normally be able
           * to use the slug, but the record will not query until the `parentKey` is set.
           */
          key: {
            type: String,
            notify: true,
            observer: '_keyChanged'
          },

          /** This is only used if `parentModel` is non-blank. If so then the record will not be queried until this is non-blank. */
          parentKey: {
            type: String,
            notify: true,
            observer: '_parentKeyChanged'
          },

          /**
           * Required. The target object receiving the binding. The object will contain the direct json properties of the record returned
           * by the backend. In additional to the record properties, an additional `backend` property object will be added to the target,
           * providing status variables to track network state as well as functions for interacting with the backend.
           *
           * The `backend` object contains the following properties:
           * @property {object} status - Stores the current state of the network connection.
           * @property {string} status.code - Equal to `uninitialized`, `ready`, `loading`, `complete` or `error`.
           * @property {boolean} status.isReady - Indicates that the client is initialized and `bl-backend-item` is ready for a value 
           *   to be placed in either `key` or `parentKey`.
           * @property {boolean} status.isLoading - A network operation is pending.
           * @property {boolean} status.isComplete - Once the initial `get` operation has completed, the status will go to `complete` and
           *   will return to `complete` whenever any additional network operations successfuly complete.
           * @property {boolean} status.isError - True if the status is 'error'.
           * @property {string} status.errorMessage - Error message from backend. Null unless `isError` is `true`.
           * @property {object} doOperation - Contains a callback to run an operation by verb.
           */
          target: {
            type: Object,
            notify: true,
            value: function() { return {} }
          },

        }
      }
      
      // #=== PUBLIC ACTION METHODS ===#

      /** 
       * Executes any of the `recordItemFormat` operations with the passed parameters and stores the response in `target`. 
       * Note: You can only run one operation at a time. And you can only call this action after the backend client is initialized.
       */
      doOperation(verb, parameters) {
        if (this.target.backend.status.isReady || this.target.backend.status.isComplete|| this.target.backend.status.isError) {
          this._updateStatus('loading');

          // Clone the parameters so we can inject the record keys without messing up the passed parameters object
          var parametersWithKeys = {
            key: this.key
          };
          if (this.parentModel && this.parentModel.length) parametersWithKeys.parentKey = this.parentKey;
          Object.assign(parametersWithKeys, parameters);

          // Build the query options
          var options = {
            formatTag: 'recordItemFormat',
            verb: 'get',
            model: this.model
          };
          if (this.parentModel && this.parentModel.length) options.parentModel = this.parentModel;
          
          // Do the query
          this.app.$.backend.doOperation(options, parametersWithKeys).then(function(response) {
            if (response && response.data) {
              var newTargetObject = response.data;
              newTargetObject.backend = this.target.backend; // preserve the backend property
              this.setProperties({target: newTargetObject}); // trigger the property change notifications with a cohesive set
              
              this._updateStatus('complete');
            } else {
              this._updateStatus('error', 'The data which was returned from the server is corrupted');
            }
          }.bind(this)).catch(function(error) { 
            this._updateStatus('error', error);
          }.bind(this)); 
        }
      }
      
      // #=== PRIVATE ACTION METHODS ===#

      /** Sets and notifies all of the target properties related to status. Only include `error` if statusCode is 'error'. */
      _updateStatus(statusCode, error) {
        var isReady = (statusCode == 'ready');
        var isLoading = (statusCode == 'loading');
        var isComplete = (statusCode == 'complete');
        var isError = (statusCode == 'error');

        this.set('target.backend.status.code', statusCode);

        // Only trigger a notification for the booleans if they are changing
        if (this.target.backend.status.isReady != isReady) this.set('target.backend.status.isReady', isReady);
        if (this.target.backend.status.isLoading != isLoading) this.set('target.backend.status.isLoading', isLoading);
        if (this.target.backend.status.isComplete != isComplete) this.set('target.backend.status.isComplete', isComplete);
        if (this.target.backend.status.isError != isError) this.set('target.backend.status.isError', isError);

        // Always trigger a notification for the error message, but ensure that it's always null if there's no error
        if (isError) this.set('target.backend.status.errorMessage', ((error && error.message) ? error.message : error));
        else this.set('target.backend.status.errorMessage', null);
      }

      /** Initializes the object bound to the target property. Adds callbacks and sets initial property values. */
      _setupTargetObject() {
        // Add to the existing target object instead of overwriting it, in case the parent element has given it extra properties
        this.set('target.backend', {});
        this.set('target.backend.status', {});
        this.set('target.backend.status.code', 'uninitialized');
        this.set('target.backend.status.isReady', false);
        this.set('target.backend.status.isLoading', false);
        this.set('target.backend.status.isComplete', false);
        this.set('target.backend.status.isError', false);
        this.set('target.backend.status.errorMessage', null);

        // No need to notify for this one
        this.target.backend.doOperation = (verb, parameters) => this.doOperation(verb, parameters);
      }

      // #=== LIFECYCLE EVENTS ===#

      connectedCallback() {
        if (super.connectedCallback) super.connectedCallback();

        // Add a listener for the backend client status
        this.app.$.backend.addEventListener('initialized-changed', e => this._appBackendInitializedChanged(e));
        
        // Setup the target object
        this._setupTargetObject();
      }

      // #=== LISTENER & OBSERVER METHODS ===#

      _keyChanged(newValue, oldValue) {
        if (newValue && newValue.length 
            && (!this.parentModel || (this.parentKey && this.parentKey.length))
            && (this.target.backend.status.isReady || this.target.backend.status.isComplete || this.target.backend.status.isError)) {
          this.doOperation('get');
        }
      }

      _parentKeyChanged(newValue, oldValue) {
        if (newValue && newValue.length
            && this.key && this.key.length
            && (this.target.backend.status.isReady || this.target.backend.status.isComplete || this.target.backend.status.isError)) {
          this.doOperation('get');
        }
      }

      /** 
       * This method is fired via the listener setup in `connectedCallback()`. 
       * It potentially triggers a get operation.
       */
      _appBackendInitializedChanged(e) {
        if (e.detail.value && (this.target.backend.status.code == 'uninitialized')) {
          // Set status ready and trigger a get (if one of the record identifiers is already set)
          this._updateStatus('ready');
          if (this.key && this.key.length && this.parentKey && this.parentKey.length) {
            this.doOperation('get');
          }
        }
      }

    }

    window.customElements.define(BlBackendItem.is, BlBackendItem);
  </script>
</dom-module>
