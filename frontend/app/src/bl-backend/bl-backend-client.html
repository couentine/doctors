<!-- #=== POLYMER & SHIMS ===# -->
<link rel="import" href="../../bower_components/polymer/polymer.html">

<!-- #=== SWAGGER JS CLIENT ===# -->
<!-- NOTE: This is now imported in the rails polymer.html.erb layout. -->
<!-- <script src="swagger-client.min.js" type="text/javascript"></script> -->

<!-- #=== BADGE LIST COMPONENTS ===# -->
<link rel="import" href="../bl-app/bl-app-component-mixin.html">

<!--
# Badge List Backend Client #

This is a wrapper around the 2.x version of the [Swagger JS Client](https://github.com/swagger-api/swagger-js/tree/2.x).
(The 3.0 version of the swagger js library requires a more complex build process so for now we're using the 2.x branch.)
There is only one backend client for the whole app, stored in the `<bl-app>` component with id `backend`. You can access the client
from any component using the component mixin with `this.app.$.backend`.

You shouldn't need to reference this directly from a component, though. It is designed to be used via on of the model binding elements
contained in the `bl-backend` folder.
-->
<dom-module id="bl-backend-client">
  <template>

    <style include="bl-style-classes"></style>

    <!-- #=== API ERROR DIALOG ===# -->
    <paper-dialog id="connectionErrorDialog" class="red no-title-bar" modal dynamic-align>
      <h2>Connection Problem</h2>

      <div class="dialogIcon">
        <i class="icon-connection-warning"></i>
      </div>
            
      <div class="dialogContent">
        <p>
          There was a problem connecting with the Badge List server. Please review the error message below and try reloading the page.
        </p>
        <p>
          <strong>Error Message:</strong> [[connectionErrorMessage]]
        </p>
      </div>

      <div class="buttons">
        <paper-button class="red primary" dialog-dismiss>
          Close
        </paper-button>
      </div>
    </paper-dialog>
  </template>

  <script>
    class BlBackendClient extends BlAppComponentMixin(Polymer.Element) {
      
      static get is() { return 'bl-backend-client'; }

      static get properties() {
        return {
          
          client: Object,

          initialized: {
            type: Boolean,
            value: false,
            notify: true
          },

          connectionErrorMessage: String

        };
      }

      // #=== PUBLIC ACTION METHODS ===#

      /**
       * Finds the swagger client function corresponding to an operation within the API and executes it with the passed parameters.
       * Returns a promise with a result object. The result object will have the following keys:
       * - `response` contains the response body
       * - `httpCode` contains the numeric http status code of the response
       * - `errorMessage` contains a user facing error message string if there is an error (key not included when successful)
       * 
       * @param {string} options.formatTag - The format tag (ex: `recordItemFormat`) of the operation in swagger.
       * @param {string} options.verb - The verb (get, create, delete, update, search, etc) of this operation.
       * @param {string} options.model - The model name, without the word model (ex: `badge`) of the primary model.
       * @param {string} options.parentModel - 
       *   The parent model name, w/o the word model (ex: `group`) of the secondary model if needed.
       *   Note: If verb is update or delete, then parentModel is ignored. (All deletion / updating happens at the root.)
       * @param {string} parameters - The parameters object which should be passed to the operation. 
       *   A NOTE ABOUT RECORD ID / KEY: Any parameters called `key` or `parentKey` will automatically be renamed according to the accepted
       *   parameters for the specified operation. For instance: `key` might become `id`, or `parentKey` might become `group_key`.
       */
      doOperation(options, parameters) {
        // First get the operation details (displays the network error dialog if they can't be located)
        var operationId = this.getOperationId(options);
        var operationFunction = this.getOperationFunction(options.formatTag, operationId);
        var operationParameters = this.getOperationParameters(options.formatTag, operationId);
        var operationParameterNames = operationParameters.map(function(parameter) { return parameter.name });
        var parentModel = (['update', 'delete'].includes(options.verb) ? null : options.parentModel);

        // Now setup the parameters then determine if we need to change the name of the key / parent key
        if (parameters == null) parameters = {};
        if (parameters.hasOwnProperty('key') && operationParameterNames.includes('id')) {
          // There is either an id or a key or nothing, so we only need to act if they specified key but it's supposed to be id
          parameters.id = parameters.key;
          delete parameters.key;
        }
        if (parentModel && parameters.hasOwnProperty('parentKey')) {
          // `parentKey` is never an option so we need to figure out what the appropriate parameter name is and move it over
          if (operationParameterNames.includes(parentModel + '_id')) {
            parameters[parentModel + '_id'] = parameters.parentKey;
            delete parameters.parentKey;
          } else if (operationParameterNames.includes(parentModel + '_key')) {
            parameters[parentModel + '_key'] = parameters.parentKey;
            delete parameters.parentKey;
          } else {
            this.showErrorDialog('Could not find a parent key parameter for this operation');
            console.log(operationId);
            console.log(operationParameterNames);
            console.log(parameters);
          }
        }

        // Add the csrf token if needed
        var authOptions = (options.verb == 'get') ? null : { 
          clientAuthorizations: {
            csrf_token: new SwaggerClient.ApiKeyAuthorization('X-CSRF-Token', this.app.manifest.csrf_token, 'header')
          }
        };

        return new Promise(function(resolve, reject) {
          operationFunction(parameters, authOptions).then(function(responseDetails) {
            resolve({
              response: responseDetails.obj,
              httpCode: responseDetails.status,
            });
          }).catch(function(error) {
            if (error && error.obj && error.obj.errors) {
              reject({
                response: error.obj, 
                httpCode: error.status,
                errorMessage: (
                  error.obj.errors.map(errorItem => {
                    return errorItem.detail || errorItem.title;
                  }).join(". ") + '.'
                ),
              });
            } else {
              reject({
                response: null,
                httpCode: error.status,
                errorMessage: 'There was a problem communicating with the server. Please try again later.'
              });
            }
          }.bind(this));
        }.bind(this));
      }

      /**
       * Finds a specific operation in the API and returns the operation id.
       * 
       * @param {string} options.formatTag - The format tag (ex: `recordItemFormat`) of the operation in swagger.
       * @param {string} options.verb - The verb (get, create, delete, update, search, etc) of this operation.
       * @param {string} options.model - The model name, without the word model (ex: `badge`) of the primary model.
       * @param {string} options.parentModel - 
       *   The parent model name, w/o the word model (ex: `group`) of the secondary model if needed.
       *   Note: If verb is update or delete, then parentModel is ignored. (All deletion / updating happens at the root.)
       */
      getOperationId(options) {
        var parentModel = (['update', 'delete'].includes(options.verb) ? null : options.parentModel);
        var pluralizeModel = this.client.apis[options.formatTag].vendorExtensions['x-blType'].toLowerCase().includes('list');
        var expectedOperationId = options.verb
          + (parentModel ? parentModel.replace(/_/g, '') : '')
          + options.model.replace(/_/g, '')
          + (pluralizeModel ? 's' : '');
        var matchingOperationIds = Object.keys(this.client[options.formatTag].operations)
          .filter(function(operationId) {
            return operationId.toLowerCase() == expectedOperationId.toLowerCase();
          });

        if ((matchingOperationIds == null) || (matchingOperationIds.length == 0)) {
          this.showErrorDialog('There were no matching operations');
          console.log('Expected operation id = ' + expectedOperationId);
          console.log(options);
        } else if (matchingOperationIds.length > 1) {
          this.showErrorDialog('There were multiple matching operations');
          console.log('Expected operation id = ' + expectedOperationId);
          console.log(options);
          console.log(matchingOperationIds);
        } else {
          return matchingOperationIds[0];
        }
      }

      /**
       * Returns the execution function for the specified API operation. 
       * Note: You can use `getOperationId` to figure out the operation id if you don't know it.
       */
      getOperationFunction(formatTag, operationId) {
        return this.client[formatTag][operationId];
      }

      /**
       * Returns the list of parameters for the specified API operation. 
       * Note: You can use `getOperationId` to figure out the operation id if you don't know it.
       */
      getOperationParameters(formatTag, operationId) {
        return this.client[formatTag].operations[operationId].parameters;
      }

      /**
       * Returns the `properties` object from the model definition. There is one key for each field.
       * `modelReferenceString` can be either a model name (ex: `BadgeEndorsement`) 
       * or a model reference string (ex: `#/definitions/BadgeEndorsement`).
       */
      modelProperties(modelReferenceString) {
        var modelName;
        
        if (modelReferenceString.includes('/'))
          modelName = modelReferenceString.split('/')[2];
        else
          modelName = modelReferenceString;

        return (this.client.definitions[modelName]) ? this.client.definitions[modelName].properties : null;
      }

      /**
       * Returns the model reference string (ex: `AppUserMembershipInputAttributes`) suitable for passing to modelProperties.
       * Pass the snake case model string along with the attribute_set (usually `input` or `output`).
       */
      getModelReferenceString(model, attribute_set) {
        return this.snakeCaseToCamelCase(model, true) + this.upperCaseFirstCharacter(attribute_set) + 'Attributes';
      }

      /** Opens the network error dialog with the specified error message.  */
      showErrorDialog(errorMessage) {
        this.connectionErrorMessage = errorMessage;
        this.$.connectionErrorDialog.open();
      }

      // #=== LIFECYCLE EVENTS ===#

      connectedCallback() {
        if (super.connectedCallback) super.connectedCallback();

        var self = this;
        var apiHost = this.app.manifest.app_root_url.replace(/https?:\/\//i, '');

        // Initialize the swagger client
        this.client = new SwaggerClient({
          url: '/docs/api/v1/internal_api.json',
          usePromise: true,
        }).then(function(client) {
          // We need to override the host if we are in a non-production environment
          if (client.host != apiHost)
            client.setHost(apiHost);
          
          self.client = client;
          self.initialized = true;
        }).catch(function(errorMessage) {
          self.showErrorDialog(errorMessage);
        });
      }

    }

    window.customElements.define(BlBackendClient.is, BlBackendClient);
  </script>
</dom-module>
