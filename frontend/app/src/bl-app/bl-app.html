<!-- #=== POLYMER & SHIMS ===# -->
<link rel="import" href="../../bower_components/polymer/polymer.html">

<!-- #=== STANDARD POLYMER COMPONENTS ===# -->
<link rel="import" href="../../bower_components/app-route/app-location.html">
<link rel="import" href="../../bower_components/app-route/app-route.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/paper-dialog/paper-dialog.html">
<link rel="import" href="../../bower_components/paper-spinner/paper-spinner-lite.html">

<!-- #=== BADGE LIST COMPONENTS ===# -->
<link rel="import" href="../bl-backend/bl-backend-client.html">
<link rel="import" href="../bl-backend/bl-backend-item.html">
<link rel="import" href="../bl-poller/bl-poller.html">
<link rel="import" href="../bl-styles/bl-styles.html">
<link rel="import" href="../bl-toast/bl-toast.html">
<link rel="import" href="../bl-styles/fonts.html">
<link rel="import" href="../bl-views/bl-view-badge-endorsements-add.html">
<link rel="import" href="../bl-views/bl-view-home.html">
<link rel="import" href="../bl-views/bl-view-app.html">

<!--
# Badge List App #

All app components should use `BlAppComponentMixin`. That provides an `app` property which points at the container.
The mixin also provides various actions for interacting with the container. (Refer to `bl-app-component-mixin.html` for more info.)
-->
<dom-module id="bl-app">
  <template>

    <style include="bl-style-classes">

      /* === LAYOUT & BASE STYLES === */
        
        :host {
          @apply --bl-font-common-base;
          
          display: block;
          position: absolute;
          top: 0; right: 0; bottom: 0; left: 0;
        }

      /* === TOAST CONTAINER === */

        #toastContainer {
          display: block;
          position: fixed;
          bottom: 6rem;
          right: 1rem;
          left: 1rem;
          z-index: 150;
        }
        @media (min-width: 840px) {
          #toastContainer {
            bottom: 0.5rem;
            right: 10rem;
          }
        }
        @media (min-width: 1200px) {
          #toastContainer {
            left: 2rem;
            bottom: 1.5rem;
          }
        }

    </style>
    
    <!-- #=== API CONNECTION TO THE BACKEND ===# -->
    <bl-backend-client id="backend"></bl-backend-client>

    <!-- #=== APP ROUTING ===# -->
    <app-location id="location" route="{{route}}" 
      url-space-regex="(^/home$)|(^/apps/[a-zA-Z0-9_-]+)|(^/[a-zA-Z0-9_-]{3,}/[a-zA-Z0-9_-]{3,}/endorsements/add)"></app-location>
    
    <app-route
      pattern="/home"
      root-level
      route="{{route}}"
      id="homeViewRoute"
      active="{{homeViewActive}}"
    ></app-route>

    <app-route
      pattern="/apps/:key"
      root-level
      route="{{route}}"
      id="appRoute"
      active="{{appActive}}"
      data="{{appRouteData}}"
    ></app-route>
    
    <app-route
      pattern="/:key"
      route="{{route}}"
      id="groupRoute"
      data="{{groupRouteData}}"
      tail="{{groupSubroute}}"
    ></app-route>

      <app-route
        pattern="/:key"
        route="{{groupSubroute}}"
        id="groupBadgeRoute"
        data="{{groupBadgeRouteData}}"
        tail="{{groupBadgeSubroute}}"
      ></app-route>

        <app-route
          pattern="/endorsements/add"
          route="{{groupBadgeSubroute}}" 
          id="addBadgeEndorsementsViewRoute"
          active="{{addBadgeEndorsementsViewActive}}"
        ></app-route>
    
    <!-- #=== APP BACKEND MODEL ITEMS ===# -->
    
    <bl-backend-item 
      model="user"
      id="backendCurrentUser" 
      target="{{currentUser}}" 
      key="[[manifest.current_user.id]]"
    ></bl-backend-item>
    
    <bl-backend-item
      model="app"
      id="backendApp"
      target="{{appRecord}}"
      key="[[appRouteData.key]]"
    ></bl-backend-item>

    <bl-backend-item
      model="app_user_membership"
      parent-model="user"
      id="backendCurrentUserAppUserMemberhsip"
      target="{{currentUserAppUserMembership}}"
      key="[[appRouteData.key]]" 
      parent-key="[[manifest.current_user.id]]"
    ></bl-backend-item>

    <bl-backend-item
      model="group"
      id="backendGroup"
      target="{{group}}"
      key="[[filteredGroupKey]]"
    ></bl-backend-item>

    <bl-backend-item
      model="badge"
      parent-model="group"
      id="backendBadge"
      target="{{groupBadge}}"
      key="[[groupBadgeRouteData.key]]"
      parent-key="[[filteredGroupKey]]"
    ></bl-backend-item>

    <bl-poller
      id="userPoller" 
      poller-id="{{userPollerId}}"
      target="{{userPoller}}"
    ></bl-poller>

    <!-- #=== APP VIEWS ===# -->

    <bl-view-home
      id="homeView"
      active="{{homeViewActive}}"
      current-user="[[currentUser]]"
      title="Home - Badge List"
    ></bl-view-home>
    
    <bl-view-app
      id="appView"
      active="{{appActive}}"
      app-record="{{appRecord}}"
      current-user="[[currentUser]]"
      current-user-membership="[[currentUserAppUserMembership]]"
      title="[[appRecord.attributes.name]] App - Badge List"
    ></bl-view-app>

    <bl-view-badge-endorsements-add
      id="addBadgeEndorsementsView"
      active="{{addBadgeEndorsementsViewActive}}"
      group="{{group}}"
      badge="{{groupBadge}}"
      current-user="[[currentUser]]"
      title="Bulk Endorse - [[groupBadge.attributes.name]] - Badge List"
      no-chat
    ></bl-view-badge-endorsements-add>

    <!-- #=== TOAST CONTAINER ===# -->
    <div id="toastContainer"></div>

    <!-- #=== CURRENT USER ASYNC POLLER DIALOG ===# -->
    <paper-dialog id="userPollerDialog" class="orange no-title-bar" modal dynamic-align>
      <h2>Setting up Your Account...</h2>

      <paper-spinner-lite active class="orange"></paper-spinner-lite>
            
      <div class="dialogContent">
        <p>
          Badge List is completing the configuration of your account, please wait.
        </p>
      </div>
    </paper-dialog>

  </template>

  <script>
    class BlApp extends Polymer.Element {
      static get is() { return 'bl-app'; }

      static get properties() {
        return {
          
          /** The manifest is required from the backend. It contains details of the logged in user and a CSRF token to use for forms. */
          manifest: {
            type: Object,
            observer: '_manifestChanged',
          },

          /** Automatically set to the current user from the manifest. */
          currentUser: {
            type: Object,
            notify: true,
          },

          /** Stores a link to the currently active view component. Managed automatically by the view mixin code. */
          activeView: {
            type: Object,
          },

          /** True if Intercom is being used and has booted. */
          intercomLoaded: {
            type: Boolean,
            value: false,
          },

          /** Used by userPoller dialog. */
          userPollerId: String,

          /** Used by userPoller dialog. */
          userPoller: Object,

          /** The app object which is currently active. Null if current view does not have a corresponding app. */
          appRecord: Object,

          /** Stores the current user's membership in appRecord, if present. */
          currentUserAppUserMembership: Object,

          /** The group object which is currently active. Null if current view does not have a corresponding group. */
          group: Object,
          
          /** The group path as computed based on the current route data. */
          filteredGroupKey: {
            type: String,
            computed: '_filteredGroupKey(groupRouteData.key)',
          },

          /** The badge object which is currently active. Null if current view does not have a corresponding badge. */
          groupBadge: Object,

          /** Stores a list of root level strings which are reserved (and thus do not get mapped to group routes). */
          reservedRootLevelPaths: {
            type: Array,
            value: function() { return ['home', 'apps']; },
          },

          /** 
           * This powers the path() helper.
           * Whenever linking to any page within the app, use the path() helper rather than hard-coding the href. 
           */
          pathMap: {
            type: Object,
            value: function() {
              return {
                session: {
                  new: '/users/sign_in',
                  delete: '/users/logout',
                },
                currentUser: {
                  edit: '/users/edit'
                },
                user: {
                  show: '/u/{key}',
                },
                group: {
                  show: '/{key}',
                  new: '/groups/new',
                },
                reportResult: {
                  index: '/report_results',
                },
                docs: {
                  index: '/docs',
                },
                website: {
                  index: '/w',
                  pricing: '/pricing',
                },
                link: {
                  community: 'https://www.badgelist.com/community',
                  bulkAwardTutorialVideo: 'https://www.youtube.com/watch?v=p2C0omou41A',
                  tutorialVideo: 'https://www.youtube.com/watch?v=cXjP7qXRqxo&t=1s',
                  csvTutorial: 'https://www.computerhope.com/issues/ch001356.htm',
                },
                template: {
                  bulkAwardingCsv: 'https://s3.amazonaws.com/badgelist/templates/badge-endorsements.csv',
                },
              };
            },
          },

        };
      }

      // #=== PUBLIC ACTION METHODS ===#

      /**
       * Displays new toast item in the app toast container. 
       * Options accepted: duration, actionFunction, actionText 
       */
      addToast(text, options = {}) {
        var newToast = document.createElement('bl-toast');
        
        newToast.text = text;
        
        if (options.duration != undefined) newToast.duration = options.duration;
        if (options.actionFunction != undefined) newToast.actionFunction = options.actionFunction;
        if (options.actionText != undefined) newToast.actionText = options.actionText;
        
        this.$.toastContainer.appendChild(newToast);
      }

      /** 
       * Sets the `hidden` flag on the intercom container element if it exists.
       * If the intercom container does not exist, then this method does nothing.
       */
      hideIntercom() {
        if (document.querySelector('#intercom-container')) {
          document.querySelector('#intercom-container').hidden = true;
        }
      }

      /** 
       * Clears the `hidden` flag on the intercom container element if it exists.
       * If the intercom container does not exist, then this method does nothing.
       */
      showIntercom() {
        if (document.querySelector('#intercom-container')) {
          document.querySelector('#intercom-container').hidden = false;
        }
      }

      // #=== LIFECYCLE EVENTS ===#

      ready() {
        if (super.ready) super.ready();

        // Remove `loading` class from the body.
        document.getElementsByTagName('body')[0].classList.remove('loading');

        // Listen for Intercom boot
        // Wait for Intercom to load (max 30 seconds)
        const timeout = setTimeout(() => clearInterval(interval), 30000);
        const interval = setInterval(() => {
          if (('Intercom' in window) && window.Intercom.booted && document.querySelector('#intercom-container')) {
            // Intercom is booted!
            clearInterval(interval);
            clearTimeout(timeout);

            if (this.activeView && this.activeView.noChat) this.hideIntercom();
            this.set('intercomLoaded', true);
          }
        }, 100);
      }

      attached() {
        if (super.attached) super.attached();

        // Build out the list of reserved root level paths by looking for all <app-route> elements with the `root-level` option.
        // NOTE: This isn't happening fast enough so for now I'm hard coding the root level routes in the default value.
        this.reservedRootLevelPaths = [...this.shadowRoot.querySelectorAll('app-route[root-level]')].map(appRouteElement => {
          return appRouteElement.pattern.split('/')[1];
        });
      }

      // #=== LISTENER & OBSERVER METHODS ===#

      static get observers() {
          return [
            '_userPollerCompletedChanged(userPoller.attributes.completed)',
            '_currentUserAsyncPollerIdChanged(currentUser.attributes.async_poller_id)',
          ]
      }

      _userPollerCompletedChanged(pollerCompleted) {
        if (pollerCompleted) {
          location.reload();
        }
      }

      _currentUserAsyncPollerIdChanged(asyncCallbackPollerId) {
        if (asyncCallbackPollerId && asyncCallbackPollerId.length) {
          this.userPollerId = asyncCallbackPollerId;
          this.$.userPollerDialog.open();
        }
      }

      _manifestChanged(newValue, oldValue) {
        if (newValue) {
          if (newValue.toast && newValue.toast.length)
            newValue.toast.forEach(function(toastItem) {
              this.addToast(toastItem.text)
            }.bind(this));
        }
      }

      // #=== PROPERTY COMPUTER METHODS ===#

      _filteredGroupKey(groupSlug) {
        if (groupSlug && groupSlug.length && !this.reservedRootLevelPaths.includes(groupSlug))
          return groupSlug.toLowerCase();
        else
          return null;
      }

      // #=== PUBLIC HELPER & UTILITY METHODS ===#

      /** 
       * Always use this helper to calculate links to different parts of the app. Don't hardcode the hrefs. 
       * This is essentially just a wrapper around `pathMap`, so when adding new paths, just add them to `pathMap`.
       *
       * @param {string} options.verb - Http verb of the action.
       * @param {string} options.model - Camel case model name. Singular. Examples: user, appUserMembership
       * @param {string} options.parentModel - Camel case parent model name. Singular.
       * @param {string} options.key - Key of the primary model, if needed for this path.
       * @param {string} options.parentKey - Key of the parent model, if needed for this path.
       */
      path(options) {
        var pathTemplate;

        if (options.parentModel) {
          if (this.pathMap[options.parentModel] && this.pathMap[options.parentModel][options.model])
            pathTemplate = this.pathMap[options.parentModel][options.model][options.verb];
        } else {
          if (this.pathMap[options.model])
            pathTemplate = this.pathMap[options.model][options.verb];
        }

        if (!pathTemplate) {
          console.log('No app path found for options = ');
          console.log(options);
          return null;
        }

        return pathTemplate
          .replace(/{key}/, options.key)
          .replace(/{parentKey}/, options.parentKey);
      }

    }

    window.customElements.define(BlApp.is, BlApp);
  </script>
</dom-module>
