<!--
# Badge List Website Component Mixin #
  
All Badge List website components should extend this mixin. It provides an `website` property that allows access to the 
`bl-website` component.

If you need to use the `assetUrl` method to set css properties, overload the `assetsLoaded` event.
-->
<script>

  BlWebsiteComponentMixin = function(superClass) {
    return class extends superClass {

      static get properties() {
        return {
          
          /** Links to the `<bl-website>` component. */
          website: {
            type: Object,
            notify: true,
          },
          
          /** This can optionally be set by the parent if the component needs access to the current user. */
          currentUser: Object,
          
          /** This can optionally be set by the parent if the component needs access the CMS preview state. */
          cmsPreviewMode: Object,

          assetLoadingComplete: {
            type: Boolean,
            value: false
          }

        };
      }

      // #=== LIFECYCLE EVENTS ===#

      connectedCallback() {
        if (super.connectedCallback) super.connectedCallback();

        this.website = document.querySelector('bl-website');
      }

      /** Overload this event to run code when the assets are loaded. (Remember to run `super.assetsLoaded()`). */
      assetsLoaded() {
        this.assetLoadingComplete = true;
      }

      // #=== LISTENER & OBSERVER METHODS ===#

      static get observers() {
          return [
            '_websiteAssetsChanged(website.manifest.assets)'
          ]
      }

      _websiteAssetsChanged(e) {
        if (this.website.manifest.assets && !this.assetLoadingComplete) {
          this.assetsLoaded();
        }
      }

      // #=== PUBLIC HELPER & UTILITY METHODS ===#

      /**
       * Checks if the first passed argument (`testValue`) is equal to any of the remaining arguments (`matchList`). You can use this to 
       * check equality between two arguments or to check if the first argument is "in" the list of remaining arguments. If you make sure 
       * that one of the arguments is dynamic it allows you to ensure that the binding is updated, rather than being set statically on 
       * page load (which is what happens with normal functional bindings).
       */
      equal(testValue, ...matchList) {
        return matchList.includes(testValue);
      }

      /**
       * Returns true if all of the passed arguments evaluate to true.
       */
      and(...args) {
        return args.reduce((returnValue, item) => {
          return returnValue && !!item;
        }, true);
      }

      /**
       * Returns true if any of the passed arguments evaluate to true.
       */
      or(...args) {
        return args.reduce((returnValue, item) => {
          return returnValue || !!item;
        }, false);
      }

      /**
       * Returns true if the passed value is non-blank.
       */
      has(testValue) {
        return (testValue && (testValue != '')) ? true : false;
      }

      /**
       * Returns true if the passed array or string contains the specified value.
       */
      contains(testValue, containsText) {
        return testValue && testValue.includes(containsText);
      }

      /**
       * Accepts a list of styles (or an undefined/null variable) and returns that array plus the additional value.
       */
      addStyle(styleList, additionalStyle) {
        var styles = styleList ? styleList.slice(0) : [];
        styles.push(additionalStyle);
        return styles;
      }

    }
  }

</script>